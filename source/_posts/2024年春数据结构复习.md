## 2024年春数据结构复习

### 第一章&第二章

- **数据项** 是数据的最小单位（组成数据元素的）（学号，性别），**数据元素**是数据的基本单位。

- $$
  \text{sum} = 1 + 2 + 3 + \ldots + i = \frac{i(i+1)}{2}
  $$

- 

- ```CPP
  int func ( int n )
  {   int i = 0, sum = 0;
      while ( sum < n )  sum += ++i;
      return i;
  }
  ```

  的时间复杂度是：

  A.*O*(*logn*)

  **B.*O*($\sqrt n$)**

  C.*O*(*n*)

  D.*O*(*nlogn*)
  
- **设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用( )最节省时间。**
  
  A.单链表
  
  B.单循环链表
  
  C.带尾指针的单循环链表

  **D.带头结点的双循环链表**

### 第三章&第四章

- **用链接方式存储的队列，在进行删除运算时（ ）。**

  A.仅修改头指针

  B.仅修改尾指针

  C.头、尾指针都要修改

  **D.头、尾指针可能都要修改**

  - ***为什么头尾指针都要修改，当有头节点的时候且队列中只有一个元素，不只要修改头指针->next。还要修改尾指针重新指向头节点。*** 

#### 循环队列

- 循环队列中，若是队尾指针和队头指针相等，存在两种情况（满或空）。**解决方法**：少用一个空间来存放元素。

  ```c
  Status EQueue(Queue& Q, ElemType) {
      if(((Q.front + 1) % Q.length) == Q.rear) {
          return ERROR; // 此时判断队已满
      }
  }
  Status DeQueue(Queue& Q, ElemType) {
      if(Q.front == Q.rear) {
          return ERROR; // 判断队空的条件
      }
  }
  ```

- 在链队中直接操作的可能默认的是有区分于头节点和首元节点的，不能直接操作头指针。

- ```c
  Status EnQueue(LinkQueue &Q, QElemTYpe e) {
      if(Q.rear == Q.front) {
          return 0; // 判空
      }
      ptr p = Q.front->next; // 操作的一般是front->next
      e = p->data;
      Q.front->next = p->next;
      if(Q.rear == p) { // 在这里验证了当出队元素的时候不只可能改变头指针的值，当只有最后一个元素的时候需要重新修改尾指针的值
          Q.rear = Q.front;
      }
      delete p;
      return 1;
  }
  ```

- 

- 



#### 串的字符匹配

- 数据结构中一般默认的串的第零个空间放串的长度。

- num(子串) = $\frac{n(n+1)}{2}+1$ ，加上1是空串。

- 串的模式匹配算法（BF算法）：暴力的一个一个进行判断

  ```c
  // 重要的步骤
  int Index_BF(String S, String T, int pos) {
      // 返回模式串从pos开始第一次在子串中出现的位置
      int i = pos; int j = 1;
      while(i <= S.Length && j <= T.Length) {
          if(S[i] == T[j]) {
              i++; j++; // 匹配上了一个一个往后移        
          }
          else {
              // 匹配失败 i返回到下一个位置 j归1
              i = i-j+2; // i = i - (j - 1) + 1 这里 j-1代表的是在这一趟中一共移动的次数，+1代表移到下一个字符
              j = 1; // j 复原 = 1
          }
      }
      if(j > T.Length) {
          // 代表成功匹配
          return i-T.length;
      } else {
          return 0;
      }
  }
  
  ```

#### 压缩矩阵

- **对称矩阵**压缩后的空间大小：$\frac{n^2 - n}{2}+n$ 这里的${n^2 -n}$代表，总的元素数目-对角线的的元素数目，$/2$之后+对角线的元素$n$得到了上三角的元素。

- （**SWPU-DS）数组 A[0..5, 0..6] 的每个元素占 5 个字节，将其按*列*优先次序存储在起始地址为 1000 的内存单元中，则元素 A[5, 5] 的地址是( )。**

  **A.1175**

  B.1180

  C.1205

  D.1210

  - 做这种题目首先要关心的是按什么为优先次序，以及数组的索引是从0开始还是从1开始

### 树

**完全二叉树**：完全二叉树的度为1的节点个数只能是0或者1。相对于满二叉树，除了最后一层之外，其他每层的节点数都是最大值。、

**二叉链表**：左孩子是孩子，右孩子是兄弟。

在二叉树结点的先序序列，中序序列和后序序列中，所有叶子结点的先后顺序完全相同。

### **图论**

**完全图**：有向完全图$n*(n-1)$个节点，无向完全图$\frac{n(n-1)}{2}$个节点。

**网**：带权的图就是网。



**最小生成树**：

**prim**算法， **kruskal**算法。

分别被称为“找点法”， “找边法”。

```cpp
void mini_SpanTree_Prim() {
    
}













```





## 错题收集

- **假定有k个关键字互为同义词，若用线性探测再散列法把这k个关键字存入散列表中，至少要进行（ ）次探测。**

  A.k(k-1)/2

  **B.k(k+1)/2**

  C.k/2

  D.(k-1)/2

- **下图所示的 AOE 网表示一项包含 8 个活动的工程。活动 d 的最早开始时间和最迟开始时间分别是：**

  ![GRE19-5.jpg](https://images.ptausercontent.com/28de33de-076f-4f94-b856-445865994fb0.jpg)

  **A.12 和 14**

  B.3 和 7

  C.12 和 12

  D.15 和 15

  - 活动d的最早发生时间=事件2的最早发生时间**=max**{**2**, **4*+*****8**}= 12,最晚发生时间=事件4的最晚发生时间-权值7。

  - **关键路径**：是指在工程中需要时间最长的一条路径，当关键路径上的所有事件和活动都完成了，才能保证这个工程的其他所有非关键路径也都完成了。**关键路径上的事件（顶点）的最早发生时间=最晚发生时间**。

  - 找**事件**（顶点）的最早发生时间，和最晚发生时间。最早发生时间 = max{入度的边数的权值}。最晚发生时间=工程**汇点**（汇点的最晚发生时间 = 最早发生时间）- 边的权值。

  - 找**活动**（边）的最早发生时间，最晚发生时间。口诀“**早头晚尾**”，最早发生时间 =**前面的事件的最早发生时间**， 最晚发生时间=**后面事件的最晚发生时间-边的权值**。

    