---
title: 2024春13周
date: 2024-06-04 07:38:33
tags: 学习记录

---

### 前记

很早就想着手开始记录，写自己的学习记录，和知识性质的总结。最近有想到，索性就把这个时间间隔节点给定在了一周一次吧，一周的时间还是挺重要挺多的，一周着实是占到了一年的2%。先开的这个专栏主要是，记录自己在自学CS的途中，大步向前走的步伐。最近可能就是包括，CSAPP这一个超大头的学习。希望能坚持下去这个习惯，这是一个正反馈的，送给自己的一份财富。

#### CSAPP

这一周加上上一周，还是没有忍住开了CSAPP这个大坑，说好的先把CS106x课程给结束，在开始进入这个大坑的呢。还是这样双头并行式进行运作吧。CS106x也是快完结了。

​	上一周主要是以第二章的内容居多。

##### 第二章 信息的表示和处理

**总结核心：所有数字在整数形式方面在计算机中都是通过二进制位串来进行表示的，只是为表示不同的数字，而存在的不同的解读方式。特别是二进制位串的符号位，也就是二进制位向量的最高有效位，是区分无符号整数和补码整数表示（通俗的说其实就是有了符号的整数）的有具体标志。而浮点数的表示，则是通过特殊的科学计数法的形式进行表示。** **整章都需要有类比十进制的思维**。

**第二章主要讲的是信息的表示和处理，总的来说，讲了最重要的三种在计算机中的数字表示：**

**无符号编码：**无符号编码主要是传统的二进制表示法表示大于或等于的零的数字。

**补码编码**：二进制的首位，以1或0来表示数的正负。

**浮点数编码**：以特殊的以2为基数的科学计数法来表示的编码方法。

**前瞻知识**

* 计算机使用8位的块，称为字节，来作为最小的可寻址的内存单位。**虚拟地址空间**
* 十六进制的表示法，掌握了十六进制，十进制和二进制之间的熟练转换。
* word size(字长)， 每个计算机都有一个字长，决定了系统的虚拟地址空间的最大大小，字长2^w位，虚拟地址的范围0~2^w-1位，程序最多访问2^w字节。
* 在计算机中排列一个对象的两个字节的通用规则：**小端法和大端法**。而这通常依赖于机器的类型。
  * **小端法**：最低有效位字节储存在字节数组前面。
  * **大端法**：最高有效位字节储存在字节数组前面。
* 位串的位级别的运算、**算术右移**、**逻辑右移**、**左移运算**。

**整数的运算**

* 二进制位串的每一位都有权重，类比于十进制数字的表示方法。同时补码编码的首位权重依然存在，只不过是带上了负号进行运算。

* 既然存在固定的位数来表示数字，那么就一定存在位数不够的情况。这样就导致了**溢出**。

  * 数字从一种数据类型到另一种数据类型，发生的溢出是，位向量解释差异的后果，或者说从一个大的数据类型转换到小的数据类型必然存在位数不够的情况，这时就会发生**截断位数**
    * **截断位数**：指的是取得末尾的w位数字，丢弃前面的超出w位的数字来表示运算结果的方法。通常通过取模运算来进行（类比十进制取末位数）    x' = x mod 2^w。截断位数，在整数的乘法中依然存在。
  * 同样的，溢出当然发生在运算之中，这就是为什么一个正数经过运算之后会变成一个很小的负数。**由补码编码的-1，转换为无符号整数便是最大的UMax**。

* 计算机中的运行乘法的效率远比进行加减法运算低，所以计算机更加倾向于将乘法运算转换为移位和加法减法的组合来消除很多整数乘以常数的情况。

  >
  >
  >x * 14 = (x << 3) + (x << 2) + (x<<1)

**浮点数的表示方法**

>
>
>浮点数对形如 V=   x*2^y 的有理数进行编码

**主要形式**：IEEE的浮点标准

>
>
>V = (-1)^s * M * 2^E

其中s决定该浮点数是正数还是负数，M是尾数（具体的值视情况而定），E是阶码。

**浮点数位表示分为三个字段**：

* 一个单独的符号位直接编码符号s。
* 紧跟着的是k位的阶码字段exp，编码阶码E。
* n位的小数字段frac代表的是小数f，编码尾数M。

**具体的运算则根据exp的值**，被编码的值分为三种不同的情况，最后一种情况有两种变体。

* 规格化的 (exp != 0)
* 非规格化的(exp =0)
* 无穷大(exp = max && frac = 0)
* NaN (***Not a Number***)(exp = max && frac != 0)

至此这周的CSAPP就完成了，课后的家庭作业做的我很抓狂。这一章刚开始也是我最抗拒的一张，现在梳理了一下确实好了很多，但家庭作业中一些技巧和具体的实现，还是比较困难。有时间再来继续补充吧。

****

#### cs106x

这一周，终于完成了boggle的作业，一直以为是其中的回溯算法问题，从上上周的周末一直拉到了上周的周末（好像是）才最终发现，问题出在了把初始化一个Lexicon的任务放在了一个，函数中，导致每一次要进行判断单词的时候，多次调用这个函数，初始化这个lexicon，时间耗费过于庞大，导致没有完成。也算是踩到了一个坑吧。

进度方面，由于一些畏惧，或者说是冠冕堂皇的理由，我跳过了*assignment 4 ADTs and recursion*，因为这个确实是我的弱项，如果专注这个的话，估计又要耗费大量时间，总的来说上一周的主题就是回溯，完成了Hello算法题单里的回溯题，当然大部分时间都是在看题解，理解题解，背题解（），每周一到两个的算法题目标，也算是完成了，这次就不写**算法**专栏了。

然后我是突然发现，原来cs106x后面的课程，才开始讲数据结构，开始讲真正的自己实现一个数据结构，和课上讲的有些重复了，可以快速地刷完当作复习了，然后就是完成*assignment*，这门课也一定很快就会结课了！

****

这一次的总结从，七点四十多写到了现在，还是觉得或许耗费的时间太多了？但是应该是值得花这个时间进行梳理和总结的，希望是值得的。感觉现在完成一个任务确实花的时间比自己预想的时间要多得多，慢慢变好吧。

















