---
title: 2024春14周
date: 2024-06-09 19:17:54
tags: 学习记录
---

### 前记

又是新的一周结束了，这周显得比较跌宕起伏，没有能做到完全的全身心地投入到CS中去，和高考相重的端午假期，显然前一个事情更加让我思绪万千，但这是学习总结题，所以不必讲太多。总的来说，这一周感觉还是没有达到自己的预期 ，CSAPP选择了推进第三章，而CS106X也是在“堆”处苦久矣。

#### CSAPP

好的这一周csapp正式进入了第三章**程序的机器级表示**，还是选择跳过了第二章后面很大篇幅的家庭作业，因为我本身也知道，没能完全系统的去学，确实是没有记住一些小技巧和一些本质公式，做起来确实是想脑筋急转弯一样，但是看了答案，思考一番就恍然大悟的这个现象，也被教授给揶揄过。最终选择了跳过，继续向前推动，了解更多的我想要知道的更多的新知识，当然以这种方式来进行回顾，我相信这是有价值的。就像我不止一次的想到，来了解这些底层的计算机知识真的对我有很大帮助吗，为什么不去学习一些**以后工作上要用到的东西**呢，答案相信我是心知肚明的，大家都是心知肚明的。

##### 第三章：程序的机器级表示

**当然，这一章的主题就是计算机执行机器代码，介绍更多的底层的处理器的细节以及，详细学习一种特别的汇编语言。机器语言的表述则是现在1最常见的处理器的机器语言——x86-64，是一个属于Intel处理器系列的一个集大成者。**

- 四种主要的寄存器：

  - **程序计数器**(PC)(**Program** **counter**)：主要用于存储将要执行的下一条的指令在内存中的地址。
  - **整数寄存器**：主要介绍和使用的。包含16个命名的位置，分别存储64位的值。
    - 16个命名的位置，每一个位置又分别被分为64，32，16，8位的不同位数的低位寄存器。分别对应四种特定的数据格式类型，**四字(quad word)， 双字(long word)，字(word)，字节(byte)**
    - 这里的寄存器划分显得非常重要和有趣，相当于一个64位的寄存器按照特定的数量位数的分配，划分成了几个低位的寄存器，相当于在进行位级别的操作和运算的时候，特定的位级操作只能访问特定的位数的寄存器，***截断***。
    - 同时给这些寄存器还会用来记录某些重要的程序状态，%rsp通常作为栈指针指示栈的位置，其他一部分用来记录过程的参数和局部变量，函数的返回值(%rax)。
  - **条件码寄存器**：用于实现控制和数据流中的条件变化。
  - **向量寄存器**：可以存放一个或多个整数或浮点值。

- **操作数指示符**：

  - **操作数**(operand)：大多数的指令都会有一个或者多个的操作数，指示源数据值，放置结果的目的位置。有着相应的三种类型的操作数。

    - 立即数（用来表示常数值），寄存器(register)，内存引用。

      - **内存引用**， 根据其计算出来的的地址（有效地址），直接去访问某一个内存位置。
      
    
  - 正是有了这三种类型的操作数，产生了多种不同的寻址模式，允许不同形式的内存引用。详情见原书P121。**存在着一个完全通用的格式其他全都是变式**。
  
    > ​	grammar： Imm(rb, ri, s)  
  
    其中Imm 是个立即数的偏移，rb是基址寄存器， ri是变址寄存器， s则是一个比例因子（1，2，4，8）。有效地址则等于 ***Imm+R[rb]+ R[ri] · s***。
  
-  数据传输指令

  - ***pushq*** 指令，push 则是将操作数里的引用的值给压入栈的效果， q则指的是操作数的大小（quad word）操作的对象是四字。相对应的 ***popq***指令则是弹出数据的指令，这两个指令共同实现了一个压入和弹出栈数据的效果。
  - 在机器内部的实现的栈中，“**栈底**”处在地址高位处，“**栈顶**”处在地址低位处。寄存器***%rsp***，实现了记录栈顶指针的效果，实质则是，***%rsp***中存储了一个指向栈顶的指针。压栈->减小栈指针的值（栈顶在下，向下），出栈->增大栈指针的值（栈底在上，指针向上）。

- 算术和逻辑操作

  - 一些常见的特定的算术和逻辑操作对应的运算指令。
  - ***leaq***指令：加载有效地址。指令形式：从内存读数据到寄存器。实质上是，它产生了一个指向其中源地址的指针，他的操作对象是有效地址，并不是也没有引用地址里的值进行操作，这也使得他可以进行很多简单地址的算术操作。P129
  - 特殊的算术操作：当发生算术的溢出时，eg：两个64位数字得到128位的乘积的整数除法的指令，也详细的分为了有符号和无符号对应的指令。
  - ***imulq***,***mulq***,这里作为全乘法的指令 **只有一个单操作数**，用于从两个64位操作数产生一个64位乘积。其中一个参数提前必须存放在 ***%rax***中， 另一个作为源操作数给出。结果存放在 ***%rdx***(高64位) ***%rax***(低64位)中。--固定用法。
  - 除法则完全和乘法相反。将寄存器中的 ***%rdx***(高64位) ***%rax***(低64位)128位数作为的**被除数**，除数是源操作数。 ***商储存在%rax，余数储存在%rdx中***。P135




#### CS106X

这一周的CS106x, 可谓是挫折多端，将整个一周的时间都给花在了**assignment** **4**上，主要是自己实现优先队列，用四种不同的数据结构类型，现在只剩下了最后一个，Binomial Heap (二项堆？)的实现了，事实是文档还没有花时间去看。是下一周的任务了。其中反而花的时间的最多的进行调试debug的，反而是很简单的数据结构***heap***，也算是真正的复习了一遍堆的概念和堆相对应的操作和实现，这次的assignment同时也锻炼了，我的一些些面向对象的一些知识和基础，大多数都体现在类的建立和实现上。

- 堆的定义，堆性质和定义只能确保堆顶元素的满足整个堆的最大最小，性质：父代永远大于（小于）子代，兄弟节点之间在进行标准形式的堆化的时候是无法进行保持原来的顺序的。堆化操作，上堆化和下堆化。
	
  ```c++
  // 下堆化操作
  void heapify(int index){
      while(1) {
      	int l = getLchild(index);
      	int r = getRchild(index);
      	int max = index;
      	if(l < heapSize && l > heap[max]) {
      		max = l;
      	} 
      	// 这里一定不能写else if 要搞清楚这里的逻辑所在
          if(r < heapSize && r > heap[max]) {
              max = r;
          }
          if(max == index) {
              break;
          }
          swap(heap[max], heap[index]);
          // 继续向下堆化
          index = max;
      }
  }
  ```

- ***添加新元素***，维持堆的性质

  ```c++
  void insert(ElemType elem) {
      heap[size++] = elem;
      siftUp(size-1);
  }
  // 这里也要注意索引的求法，当用数组实现时，孩子和parent的索引，考虑从数组的0开始和1开始的不同的情况
  void siftUp(int index) {
      while(1) {
          int parent = getParent(index);
          if(parent >= 0 && heap[parent] < heap[index]) {
              swap(heap[parent], heap[index]);
              index = parent;
              parent = getParent(index);
          }
          else break;
      }
  }
  ```

- 同时没有完全依赖于cpp的容器，正常的c编程方式，在类中的内存管理。
